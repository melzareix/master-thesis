\chapter{Conclusion}\label{chapter:conclusion}
This thesis presented our prototype implementation of a performant automata-based regular expressions engine with Unicode support and dynamic compilation built on top of the LLVM compiler infrastructure.

Our implementation aims to be used as a sub-engine inside a DBMS. It aims to deliver high performance on commonly used regular expressions while acknowledging that not all expressions can be handled by the underlying method, which also has significant memory and compilation time requirements.

Performance evaluations of the prototype to other popular general purpose regular expression engines show promising results. On a dataset with millions of rows and medium-sized patterns we were able to achieve a speedup of $2.5x$ against PCRE2 and $1.2x$ against RE2. These results how adding JIT-compilation is beneficial over large data-sets and the cost of compilation is amortized over the large number
of runs.

\section{Future Work}

Future work should focus on extending the engine features and optimizations. Possible features include:
\begin{itemize}
    \item \textbf{Full Unicode Support}: Full Unicode Level 1 support should be added followed by Unicode level 2 support.
    \item \textbf{Regex Features}: Currently we only support a basic subset of RegExp features. We could extend the engine to not only report matches but also report the matching boundaries. Word-boundaries, Capture groups and lookaheads are also popular features that could be useful to add and test its performance.  
    \item \textbf{Adaptive Compilation}: The engine currently always JITs the DFA before execution which is costly for patterns that are executed on a small number of rows. We could improve this by doing adaptive compilation where we dynamically switches from interpretation to compilation only when needed.
\end{itemize}

The current engine while achieving good performance only includes a small subset of optimizations. It can be extended to include  DFA minimization algorithms e.g Hop-Croft algorithm to further reduce the code generated and DFA transitions. SIMD optimizations through RegExp decomposition only all expressions is also another important optimization. An pattern e.g. \texttt{\textbf{ab|cd}} could be decomposed to two expressions \texttt{\textbf{ab}} and \texttt{\textbf{cd}} and EPSM algorithm used to search for the patterns instead of using the DFA.